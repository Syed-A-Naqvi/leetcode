# Container With Most Water

## Problem Description

You are given an integer array `heights` where `heights[i]` represents the height of the $i^{th}$ bar.

You may choose any two bars to form a container. Return the *maximum* amount of water a container can store.

#### Example 1:
```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

#### Example 2:
```
Input: height = [2,2,2]

Output: 4
```

#### Example 3:
```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

#### Constraints:
- `2 <= height.length <= 1000`
- `0 <= height[i] <= 1000`



## Solution 1

**Approach**: We want to start the pointers at either end of the `heights` array. We move the pointers inwards by decrementing/incrementing the pointer with the lower height bar. Each iteration, we calculate the current area and update the max known area as appropriate. we continue until the left pointer is the the right of the right pointer. This will result in use having compared the area generated by the two tallest bars with the total possible area resulting from all shorter bars.  

1. Start with pointer `i = 0` and pointer `j = heights.size()-1` and loop while `i < j`.
    - Calculate the current area using `min(height[i], height[j]) * (j - 1)` and update `maxArea` if `currArea > maxArea`.
    - If `height[i] > height[j]` then `j--` since `j` points to the shorter bar, else `i++` in case of a tie or if `i` points to the shorter bar.
2. return maxArea.


### Complexity
- **Time Complexity**: Total number of elements traversed by each pointer is `n` $\rightarrow$ `O(n)`.
- **Space Complexity**: Constant number of additional variables created $\rightarrow$ `O(1)`.