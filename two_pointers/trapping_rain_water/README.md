# Trapping Rain Water

## Problem Description

You are given an array of non-negative integers `height` which represent an elevation map. Each value `height[i]` represents the height of a bar, which has a width of `1`.

Return the maximum area of water that can be trapped between the bars.

#### Example 1:
```
Input: height = [0,2,0,3,1,0,1,3,2,1]

Output: 9
```

#### Constraints:
- `1 <= height.length <= 1000`
- `0 <= height[i] <= 1000`


## Solution 1

**Approach**: We want to start the pointers at either end of the `heights` array. We move the pointers inwards by decrementing/incrementing the pointer with the lower height bar. Each iteration, we calculate the current area and update the max known area as appropriate. we continue until the left pointer is to the right of the right pointer. This will result in us having compared the area generated by the two tallest bars with the total possible area resulting from all shorter bars.  

1. Start with pointer `i = 0` and pointer `j = heights.size()-1` and loop while `i < j`.
    - Calculate the current area using `min(height[i], height[j]) * (j - 1)` and update `maxArea` if `currArea > maxArea`.
    - If `height[i] > height[j]` then `j--` since `j` points to the shorter bar, else `i++` in case of a tie or if `i` points to the shorter bar.
2. return maxArea.


### Complexity
- **Time Complexity**: Total number of elements traversed by each pointer is `n` $\rightarrow$ `O(n)`.
- **Space Complexity**: Constant number of additional variables created $\rightarrow$ `O(1)`.